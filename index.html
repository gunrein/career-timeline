<!DOCTYPE html>
<html lang="en">
<!--
This file is a self-contained web page with no external dependencies besides a modern standards-compliant
web browser. By relying only on web standards this page should stay working for longer without maintenance.
-->
<head>
  <meta charset="UTF-8">
  <title>Career timeline as of October 2025</title>

  <style>
    main {
      display: flex;
      flex-wrap: wrap;
    }

    details {
      border: 1px solid #aaaaaa;
      border-radius: 4px;
      padding: 0.5em 0.5em 0;
      cursor: pointer;
    }

    summary {
      font-weight: bold;
      margin: -0.5em -0.5em 0;
      padding: 0.5em;
    }

    details[open] {
      padding: 0.5em;
    }

    details[open] summary {
      border-bottom: 1px solid #aaaaaa;
      margin-bottom: 0.5em;
    }
  </style>
</head>
<body>

<main>
  <section class="timeline-container">
    <h2>Timeline</h2>
    <div>
      <input type="range" id="event-index" name="event-index" min="0" max="6" value="0" />
      <label for="event-index">Event Index</label>
    </div>

    <svg width="800" height="800" id="timeline-svg">
      <defs>
        <marker id="circle" viewBox="0 0 10 10" markerUnits="strokeWidth" markerWidth="6" markerHeight="6" refX="5" refY="5" orient="auto">
          <circle r="2" cx="5" cy="5" fill="gold" />
        </marker>
      </defs>
    </svg>
  </section>

  <section>
    <details name="career-steps"
             open>
      <summary>Event 1</summary>
      <p>Label</p>
      <p>June 2023</p>
      <ul>
        <li>Highlight 1</li>
        <li>Highlight 2</li>
      </ul>
    </details>

    <details name="career-steps">
      <summary>Event 2</summary>
      <p>Label</p>
      <p>June 2023</p>
      <ul>
        <li>Highlight 1</li>
        <li>Highlight 2</li>
      </ul>
    </details>

    <details name="career-steps">
      <summary>Event 3</summary>
      <p>Label</p>
      <p>June 2023</p>
      <ul>
        <li>Highlight 1</li>
        <li>Highlight 2</li>
      </ul>
    </details>

    <details name="career-steps">
      <summary>Event 4</summary>
      <p>Label</p>
      <p>June 2023</p>
      <ul>
        <li>Highlight 1</li>
        <li>Highlight 2</li>
      </ul>
    </details>
  </section>
</main>

<script>
  // @ts-check
  // Type definitions
  // Even though JavaScript doesn't have a way to declare types, TypeScript JSDoc allows tooling to type check
  // JavaScript. https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html

  /**
   * @typedef {Object} MonthYear
   * @property {number} month (1 is January, 12 is December)
   * @property {number} year the calendar year
   */
  /**
   * @param {number} month
   * @param {number} year
   * @returns MonthYear
   */
  function month(month, year) {
    return {
      month,
      year
    }
  }

  /**
   * @typedef {Object} Event
   * @property {String} label
   * @property {MonthYear} month
   * @property {String[]} highlights
   */
  /**
   * @param {String} label
   * @param {MonthYear} month
   * @param {String[]} highlights
   * @return {Event}
   */
  function event(label, month, highlights) {
    return {
      label,
      month,
      highlights
    }
  }

  /**
   * @typedef {Object} Point
   * @property {number} x
   * @property {number} y
   */
  /**
   * Constructs a Point from the given (`x`, `y`) coordinates.
   * @param {number} x
   * @param {number} y
   * @return {Point}
   */
  function point(x, y) {
    return { x, y }
  }

  /**
   * Represents a `C` cubic bezier curve in an SVG `<path>` element.
   * @typedef {Object} PathCubic
   * @property {Point} one
   * @property {Point} two
   * @property {Point} end
   */
  /**
   * Constructs a PathCubic
   * @param {Point} one
   * @param {Point} two
   * @param {Point} end
   * @return {PathCubic}
   */
  function pathCubic(one, two, end) {
    return { one, two, end };
  }

  // TODO parse from `details`
  const careerEvents = [
    // event("Event 0", month(1, 1986), []),
    event("Event 1", month(1, 2001), []),
    event("Event 2", month(8, 2004), []),
    event("Event 3", month(4, 2010), []),
    event("Event 4", month(2, 2011), []),
    event("Event 5", month(8, 2013), []),
    event("Event 6", month(10, 2020), []),
  ];

  /**
   * Updates the spiral visualization to represent the progression until `eventIndex`
   * @param {number} eventIndex the event to stop the spiral rendering at
   */
  function updateSpiral(eventIndex) {

    // The timeline visualize is rendered as an Archimedean spiral
    // https://en.wikipedia.org/wiki/Archimedean_spiral
    // One cycle of the spiral represents a year, so the radians per month is calculated as
    // 2*pi radians per year = 2*pi / 12 radians per month
    const radiansPerMonth = Math.PI / 6;

    /**
     * The `beta` parameter for the polar equation `r = beta * phi`.
     * @type number
     */
    const beta = 3;

    /** @type {Point} */
    const origin = point(250, 250);

    /** @type {PathCubic[]} */
    const pathOfCubic = [];

    /**
     * @typedef {Object} PathSegment
     * @property {number} start the count of months from the origin month
     * @property {number} end the count of months from start
     */

    /**
     * @param {number} start
     * @param {number} end
     * @returns {PathSegment}
     */
    function pathSegment(start, end) {
      return { start, end }
    }

    /**
     * @type {PathSegment[]}
     */
    const segments = careerEvents.slice(0, eventIndex + 1)
        // Transform each event into a count of months from the origin of the spiral to the end of the moment of the event
        .map((current, index, arr) => monthDelta(arr[0].month, current.month))
        // Record each segment as a start and end for easier rendering below
        .reduce((accumulator, current, index, arr) => {
          const start = index === 0 ? current : arr[index - 1];
          return [...accumulator, pathSegment(start, current)]
        }, []);

    /**
     * Calculates the number of months between `earlier` and `later`.
     * @param {MonthYear} earlier
     * @param {MonthYear} later
     * @returns {number}
     */
    function monthDelta(earlier, later) {
      return (later.year - earlier.year) * 12 + (later.month - earlier.month);
    }

    const newElements = [];
    segments.forEach((segment) => {
      const segmentLength = segment.end - segment.start;
      if (segmentLength === 0) {
        // Draw a point rather than a path
        // The location of the circle is the location of the current month.
        const circlePhi = segment.start * radiansPerMonth;
        const circleR = beta * circlePhi;
        const circleX = circleR * Math.cos(circlePhi) + origin.x;
        const circleY = circleR * Math.sin(circlePhi) + origin.y;

        const circleElement = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circleElement.setAttribute("cx", circleX.toString());
        circleElement.setAttribute("cy", circleY.toString());
        circleElement.setAttribute("r", "2");
        circleElement.setAttribute("fill", "gold");
        circleElement.setAttribute("stroke", "gold");
        circleElement.setAttribute("stroke-width", "2");

        newElements.push(circleElement);
      } else {
        // Draw a path
        for (let i = segment.start; i < segment.end; i++) {
          // Each segment of the spiral is rendered as an SVG `path` utilizing the `C` command
          // for a cubic BÃ©zier curve.
          // The starting point for `C` is the ending of the previous path segment.
          const startPhi = (i - 1) * radiansPerMonth;
          const startR = beta * startPhi;
          const startX = startR * Math.cos(startPhi) + origin.x;
          const startY = startR * Math.sin(startPhi) + origin.y;

          // The ending point for `C` is the location of the current month.
          const endPhi = i * radiansPerMonth;
          const endR = beta * endPhi;
          const endX = endR * Math.cos(endPhi) + origin.x;
          const endY = endR * Math.sin(endPhi) + origin.y;

          // The middle control point is an approximation where phi is set to the radians halfway between the previous
          // month and the current month, and then shifted out from the origin wider by 1/20 of beta. Visually this
          // seems to approximate the spiral well and scales up and down reasonably.
          const midPhi = startPhi + ((endPhi - startPhi) / 2.0);
          const midR = (beta + (beta / 20.0)) * midPhi;
          const midX = midR * Math.cos(midPhi) + origin.x;
          const midY = midR * Math.sin(midPhi) + origin.y;

          pathOfCubic.push(pathCubic(point(startX, startY), point(midX,midY), point(endX, endY)))
        }
        // Construct
        const pathCommands = pathOfCubic.map((value) => `C ${value.one.x} ${value.one.y}, ${value.two.x} ${value.two.y}, ${value.end.x} ${value.end.y}`)
            .reduce((left, right) => ` ${left} ${right}`, `M ${origin.x} ${origin.y}`);

        const pathElement = document.createElementNS("http://www.w3.org/2000/svg", "path");
        pathElement.setAttribute("d", pathCommands);
        pathElement.setAttribute("fill", "none");
        pathElement.setAttribute("stroke", "darkgreen");
        pathElement.setAttribute("stroke-width", "2");
        pathElement.setAttribute("marker-start", "url(#circle)");
        pathElement.setAttribute("marker-end", "url(#circle)");
        newElements.push(pathElement);
      }
    });

    const timelineSvg = document.getElementById('timeline-svg');
    // Remove all the existing path and circle elements before replacing them.
    // An improvement would be to animate the change in the spiral shape.
    timelineSvg.querySelectorAll(":scope > path, :scope > circle")
        .forEach((element) => element.remove());

    // Add the new paths
    newElements.forEach((element) => timelineSvg.appendChild(element));
  }

  // Attach an event listener to each `details` element with the name `career-steps`.
  document.querySelectorAll('details[name="career-steps"]')
      .forEach((element, index) => element.addEventListener("toggle", (event) => {
        if (event.target.open) {
          // TODO instead of document order index, change updateSpiral to take the step data itself so the index doesn't matter any more
          updateSpiral(index);
        }
      }));

  // Draw the initial spiral
  updateSpiral(0);

  // Keyboard navigation. The logic is simple and takes advantage of the behavior of named `details` open and the
  // structure of the document.
  // By opening the previous or next sibling to the currently-open `details` element the 'toggle' event handling
  // will be triggered and the correct spot in the timeline will be selected and rendered. One downside of this
  // approach is that if no `details` is already open then keyboard navigation will do nothing, but that can be
  // a future improvement.
  // Use `w` for earlier and `s` for later to avoid arrow keys causing scrolling.
  document.addEventListener('keydown', (event) => {
    if (event.key === 'w') {
      const openDetails = document.querySelector("details[open]");
      if (openDetails?.previousElementSibling) {
        openDetails.previousElementSibling.open = true;
      }
    } else if (event.key === 's') {
      const openDetails = document.querySelector("details[open]");
      if (openDetails?.nextElementSibling) {
        openDetails.nextElementSibling.open = true;
      }
    }
  })
</script>

</body>
</html>