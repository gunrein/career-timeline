<!DOCTYPE html>
<html lang="en">
<!--
This file is a self-contained web page with no external dependencies besides a modern standards-compliant
web browser. By relying only on web standards this page should stay working for longer without maintenance.
-->
<head>
  <meta charset="UTF-8">
  <title>Career timeline as of October 2025</title>

  <style>
    main {
      display: flex;
      flex-wrap: wrap;
    }

    details {
      border: 1px solid #aaaaaa;
      border-radius: 4px;
      padding: 0.5em 0.5em 0;
      cursor: pointer;
    }

    summary {
      font-weight: bold;
      margin: -0.5em -0.5em 0;
      padding: 0.5em;
    }

    details[open] {
      padding: 0.5em;
    }

    details[open] summary {
      border-bottom: 1px solid #aaaaaa;
      margin-bottom: 0.5em;
    }
  </style>
</head>
<body>

<main>
  <section class="timeline-container">
    <svg width="800" height="800" id="timeline-svg">
      <defs>
        <marker id="circle" viewBox="0 0 10 10" markerUnits="strokeWidth" markerWidth="6" markerHeight="6" refX="5" refY="5" orient="auto">
          <circle r="2" cx="5" cy="5" fill="gold" />
        </marker>
      </defs>
    </svg>
  </section>

  <section>
    <!-- Note that the <details> elements should be in chronological order -->
    <details name="career-steps"
             data-start-month="1"
             data-start-year="2001"
             data-end-month="8"
             data-end-year="2004"
             open>

      <summary><span class="company">Company 1</span><span class="date-range">January 2001-August 2004</span></summary>
      <p>Label</p>
      <p>June 2023</p>
      <ul>
        <li>Highlight 1</li>
        <li>Highlight 2</li>
      </ul>
    </details>

    <details name="career-steps"
             data-start-month="8"
             data-start-year="2004"
             data-end-month="4"
             data-end-year="2010">

      <summary>Company 2</summary>
      <p>Label</p>
      <p>June 2023</p>
      <ul>
        <li>Highlight 1</li>
        <li>Highlight 2</li>
      </ul>
    </details>

    <details name="career-steps"
             data-start-month="1"
             data-start-year="2011"
             data-end-month="8"
             data-end-year="2011">

      <summary>Company 3</summary>
      <p>Label</p>
      <p>June 2023</p>
      <ul>
        <li>Highlight 1</li>
        <li>Highlight 2</li>
      </ul>
    </details>

    <details name="career-steps"
             data-start-month="8"
             data-start-year="2011"
             data-end-month="7"
             data-end-year="2013">

      <summary>Company 4</summary>
      <p>Label</p>
      <p>June 2023</p>
      <ul>
        <li>Highlight 1</li>
        <li>Highlight 2</li>
      </ul>
    </details>

    <details name="career-steps"
             data-start-month="8"
             data-start-year="2013"
             data-end-month="11"
             data-end-year="2020">

      <summary>Company 5</summary>
      <p>Label</p>
      <p>June 2023</p>
      <ul>
        <li>Highlight 1</li>
        <li>Highlight 2</li>
      </ul>
    </details>

    <details name="career-steps"
             data-start-month="10"
             data-start-year="2021"
             data-end-month="2"
             data-end-year="2023">

      <summary>Company 6</summary>
      <p>Label</p>
      <p>June 2023</p>
      <ul>
        <li>Highlight 1</li>
        <li>Highlight 2</li>
      </ul>
    </details>

    <details name="career-steps"
             data-start-month="10"
             data-start-year="2023"
             data-end-month="10"
             data-end-year="2025">

      <summary>Company 7</summary>
      <p>Label</p>
      <p>June 2023</p>
      <ul>
        <li>Highlight 1</li>
        <li>Highlight 2</li>
      </ul>
    </details>
  </section>
</main>

<script>
  "use strict";

  // @ts-check
  // Type definitions
  // Even though JavaScript doesn't have a way to declare types, TypeScript JSDoc allows tooling to type check
  // JavaScript. https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html

  /**
   * @typedef {Object} MonthYear
   * @property {number} month (1 represents January, 12 represents December)
   * @property {number} year the calendar year
   */
  /**
   * @param {number} month
   * @param {number} year
   * @returns MonthYear
   */
  function month(month, year) {
    return {
      month,
      year
    }
  }

  /**
   * @typedef {Object} Point
   * @property {number} x
   * @property {number} y
   */
  /**
   * Constructs a Point from the given (`x`, `y`) coordinates.
   * @param {number} x
   * @param {number} y
   * @return {Point}
   */
  function point(x, y) {
    return { x, y }
  }

  /**
   * Updates the spiral visualization to represent the progression until `eventIndex`
   * @param {number} eventIndex the event to stop the spiral rendering at
   */
  function updateSpiral(eventIndex) {

    // The timeline visualize is rendered as an Archimedean spiral
    // https://en.wikipedia.org/wiki/Archimedean_spiral
    // One cycle of the spiral represents a year, so the radians per month is calculated as
    // 2*pi radians per year = 2*pi / 12 radians per month
    const radiansPerMonth = Math.PI / 6;

    /**
     * The `beta` parameter for the polar equation `r = beta * phi`.
     * @type number
     */
    const beta = 1.5;

    /** @type {Point} */
    const origin = point(250, 250);

    /**
     * @typedef {Object} PathSegment
     * @property {number} start the count of months from the origin month
     * @property {number} end the count of months from start
     */

    /**
     * @param {number} start
     * @param {number} end
     * @returns {PathSegment}
     */
    function pathSegment(start, end) {
      return { start, end }
    }

    // This query assumes the only <details> elements in the document are those with date information.
    const startElement = document.querySelector('details');
    const startMonth = month(Number(startElement.dataset.startMonth), Number(startElement.dataset.startYear));
    /**
     * @type {PathSegment[]}
     */
    const segments = [];
    Array.from(document.querySelectorAll("details"))
        // Only use the elements up to the `open` <details> element
        .slice(0, eventIndex + 1)
        // Create the segments for the selected part of the timeline
        .forEach((element) => {
          const start = month(Number(element.dataset.startMonth), Number(element.dataset.startYear));
          const end = month(Number(element.dataset.endMonth), Number(element.dataset.endYear));
          // Find the distance from the starting month of the visualization and the start of this segment.
          // Do the same for the end.
          const segment = pathSegment(monthDelta(startMonth, start), monthDelta(startMonth, end));
          segments.push(segment);
        });

    /**
     * Calculates the number of months between `earlier` and `later`.
     * @param {MonthYear} earlier
     * @param {MonthYear} later
     * @returns {number}
     */
    function monthDelta(earlier, later) {
      return (later.year - earlier.year) * 12 + (later.month - earlier.month);
    }

    const newElements = [];
    segments.forEach((segment, index) => {
      const segmentLength = segment.end - segment.start;
      if (segmentLength === 0) {
        // Draw a point rather than a path
        // The location of the circle is the location of the current month.
        const circlePhi = segment.start * radiansPerMonth;
        const circleR = beta * circlePhi;
        const circleX = circleR * Math.cos(circlePhi) + origin.x;
        const circleY = circleR * Math.sin(circlePhi) + origin.y;

        const circleElement = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circleElement.setAttribute("cx", circleX.toString());
        circleElement.setAttribute("cy", circleY.toString());
        circleElement.setAttribute("r", "2");
        circleElement.setAttribute("fill", "gold");
        circleElement.setAttribute("stroke", "gold");
        circleElement.setAttribute("stroke-width", "2");

        newElements.push(circleElement);
      } else {
        // Draw a path
        /** @type {String} */
        let pathCommands = '';
        for (let i = segment.start; i < segment.end; i++) {
          // Each segment of the spiral is rendered as an SVG `path` utilizing the `C` command
          // for a cubic BÃ©zier curve.
          const startPhi = i * radiansPerMonth;
          const startR = beta * startPhi;
          const startX = startR * Math.cos(startPhi) + origin.x;
          const startY = startR * Math.sin(startPhi) + origin.y;

          // The ending point for `C` is the next month
          const endPhi = (i + 1) * radiansPerMonth;
          const endR = beta * endPhi;
          const endX = endR * Math.cos(endPhi) + origin.x;
          const endY = endR * Math.sin(endPhi) + origin.y;

          // The middle control point is an approximation where phi is set to the radians halfway between the previous
          // month and the current month, and then shifted out from the origin wider by 1/20 of beta. Visually this
          // seems to approximate the spiral well and scales up and down reasonably.
          const midPhi = startPhi + ((endPhi - startPhi) / 2.0);
          const midR = (beta + (beta / 20.0)) * midPhi;
          const midX = midR * Math.cos(midPhi) + origin.x;
          const midY = midR * Math.sin(midPhi) + origin.y;

          // The path needs to start with `M` with should match the first `C` segment start location
          if (i === segment.start) {
            // The starting position of the path
            pathCommands = `M ${startX} ${startY}`;
          }
          // Append the next C location
          pathCommands = pathCommands + `C ${startX} ${startY}, ${midX} ${midY}, ${endX} ${endY}`;
        }

        const pathElement = document.createElementNS("http://www.w3.org/2000/svg", "path");
        pathElement.setAttribute("d", pathCommands);
        pathElement.setAttribute("fill", "none");
        pathElement.setAttribute("stroke", "darkgreen");
        pathElement.setAttribute("stroke-width", "2");
        pathElement.setAttribute("marker-start", "url(#circle)");
        pathElement.setAttribute("marker-end", "url(#circle)");
        newElements.push(pathElement);
      }
    });

    const timelineSvg = document.getElementById('timeline-svg');
    // Remove all the existing path and circle elements before replacing them.
    // An improvement would be to animate the change in the spiral shape.
    timelineSvg.querySelectorAll(":scope > path, :scope > circle")
        .forEach((element) => element.remove());

    // Add the new paths
    newElements.forEach((element) => timelineSvg.appendChild(element));
  }

  // Attach an event listener to each `details` element with the name `career-steps`.
  document.querySelectorAll('details[name="career-steps"]')
      .forEach((element, index) => element.addEventListener("toggle", (event) => {
        if (event.target.open) {
          updateSpiral(index);
        }
      }));

  /**
   * Moves the selected career segment position in the direction provided by `nextElementFunction`
   * @param {function(HTMLDetailsElement): Element} nextElementFunction
   */
  function movePosition(nextElementFunction) {
    const openDetails = document.querySelector("details[open]");
    const nextElement = nextElementFunction(openDetails);
    if (!openDetails) {
      const firstDetails = document.querySelector("details");
      if (firstDetails) {
        firstDetails.open = true;
      }
    } else if (nextElement) {
      nextElement.open = true;
    }
  }

  // Keyboard navigation. The logic is simple and takes advantage of the behavior of named `details` open and the
  // structure of the document.
  // By opening the previous or next sibling to the currently-open `details` element the 'toggle' event handling
  // will be triggered and the correct spot in the timeline will be selected and rendered.
  // Use `w` for earlier and `s` for later to avoid arrow keys causing scrolling.
  document.addEventListener('keydown', (event) => {
    if (event.key === 'w') {
      movePosition((element) => element?.previousElementSibling);
    } else if (event.key === 's') {
      movePosition((element) => element?.nextElementSibling);
    }
  })
</script>

</body>
</html>